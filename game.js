let subgameBackground = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
]

let background1 = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]
]
let background2 = [
    [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48],
    [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48],
    [48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18],
    [32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34]
]
let background3 = [
    [39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41],
    [52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54],
    [65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28]
]

let background4 = [
    [39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41],
    [52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54],
    [65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15],
    [26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28]
]

let background5 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 18, 18, 18, 18, 18, 19],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 57, 58, 58, 58, 59, 29],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 67, 68, 68, 68, 69, 29],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 77, 78, 78, 78, 79, 29],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 77, 97, 78, 97, 79, 29],
    [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 27, 77, 78, 88, 78, 79, 29],
    [2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 27, 77, 79, 98, 77, 79, 29],
    [3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 37, 38, 38, 38, 38, 38, 39]
]

let background6 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 18, 18, 18, 18, 18, 19],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 7, 7, 7, 7, 7, 29],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 7, 7, 7, 7, 7, 29],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 7, 7, 7, 7, 7, 29],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 7, 7, 7, 7, 7, 29],
    [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 27, 7, 7, 7, 7, 7, 29],
    [2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 27, 7, 7, 7, 7, 7, 29],
    [3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 3, 37, 38, 38, 38, 38, 38, 39]
]
let background7 = [
    [51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 54],
    [67, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 69, 70],
    [83, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86],
    [65, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 66]
]


let rock1 = {
    x: 512,
    y: 280,
    height: 10,
    width: 10
}
let rock2 = {
    x: 712,
    y: 280,
    height: 10,
    width: 10
}
let bat1 = {
    x: 512,
    y: 232,
    height: 48,
    width: 32,
    frameX: 0,
    frameY: 1
}

let score = 0;

let backgroundCount = 1;
let boost = false;


let canvas = document.querySelector("canvas");
let context = canvas.getContext("2d");
let request;
let fpsInterval = 1000 / 15;
let then = Date.now();
let tilesPerRow = 10;
let tileSize = 16;
let backgroundCountX = 0;
let backgroundCountY = 0;
let subgameFinished = false
let paused = true
let characterSelection = false
let floor = canvas.height - 27;

let player = {
    x: 82,
    y: 148,
    height: 48,
    width: 32,
    frameX: 0,
    frameY: 0,
    xChange: 0,
    yChange: 0,
    wepon: "sword",
    health: 100,
    character: "player",
    movement: true,
    inAir: false
};

let wizard = {
    x: 0,
    y: 0,
    height: 48,
    width: 32,
    frameX: 0,
    frameY: 0,
    xChange: 1,
    yChange: 0,
    health: 100,
    character: "wizard",
    spellX: 0,
    spellY: 0,
    spellCount: 0,
    count: 0,
    movement: true
};

let lizard = {
    x: 32,
    y: 48,
    height: 48,
    width: 39,
    frameX: 0,
    frameY: 0,
    xChange: 1,
    yChange: 0,
    character: "lizard",
    count: 0,
    health: 100,
    movement: true
};

let dragon = {
    x: 600,
    y: 500,
    height: 96,
    width: 96,
    frameX: 0,
    frameY: 0,
    xChange: 1,
    yChange: 0,
    health: 200,
    character: "dragon",
    count: 0,
    movement: true
};

let skeleton = {
    x: 132,
    y: 48,
    height: 48,
    width: 32,
    frameX: 0,
    frameY: 0,
    xChange: 1,
    yChange: 0,
    count: 0,
    health: 100,
    wepon: "bow",
    bowFrameX: 0,
    bowFrameY: 0,
    character: "skeleton",
    movement: true
};


let landmine = {
    x: 80,
    y: 80,
    height: 16,
    width: 16,
    distance: 2000,
    pictureWidth: 256,
    pictureHeight: 256,
    pictureX: 0,
    pictureY: 0,
    explode: false
}

let enemiesList = []

let sword = {
    height: 194,
    width: 256,
    frameX: 0,
    frameY: 0
}

let bow = {
    height: 80,
    width: 80,
    frameX: 1,
    frameY: 0
}

let arrowSpeed = 6;
let arrowList = [];
let obstacleList = [];
let landmineList = [];
let playerImage = new Image();
let characterMale = new Image();
let characterFemale = new Image();
let swordImage = new Image();
let bowImage = new Image();
let arrowImage = new Image();
let gameover = new Image();
let lizardImage = new Image();
let skeletonImage = new Image();
let wizardImage = new Image();
let dragonImage = new Image();
let landmineImage = new Image();
let explodeImage = new Image();
let tiny16Image = new Image();
let desertImage = new Image();
let caveImage = new Image();
let grassImage = new Image();
let sewerImage = new Image();
let rock = new Image()
let bat = new Image()

rock.src = "rock.png";
bat.src = "silverbat.png";
characterMale.src = "nightelf_male1.png";
characterFemale.src = "nightelf_female.png";
lizardImage.src = "lizard.png";
skeletonImage.src = "skeleton.png";
dragonImage.src = "dragon.png"
wizardImage.src = "wizard.png";
swordImage.src = "sword.png";
bowImage.src = "bow.png";
arrowImage.src = "arrow.png";
tiny16Image.src = "tiny-16.png";
desertImage.src = "desert.png";
caveImage.src = "cave.png";
sewerImage.src = "sewer_1.png";
grassImage.src = "tiles.png";
gameover.src = "gameover.png";
landmineImage.src = "landmine.png";
explodeImage.src = "explosionFull.png";

let moveLeft = false;
let moveUp = false;
let moveRight = false;
let moveDown = false;

let level = 7;


document.addEventListener("DOMContentLoaded", init, false);



function init() {
    window.addEventListener("keydown", activate, false);
    window.addEventListener("keyup", deactivate, false);
    levelComplete(enemiesList)
}


function subgame() {
    // change
    if (score === 10*1+1) {
        paused = true
        levelComplete(enemiesList)
    }
    else if (score <= 10) {
        request = window.requestAnimationFrame(subgame);
        if (player.health <= 0) {
            window.cancelAnimationFrame(request)
        }
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);

        if (paused) {
            pause()
        }
        else {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = "#87cefa";
            context.fillRect(0, 0, canvas.width, canvas.height);

            backgroundCount = backgroundCount + 1
            if (backgroundCount === 16) {
                backgroundCount = 0;
            }
            for (let r = 0; r < 20; r += 1) {
                for (let c = 0; c < 35; c += 1) {
                    let tile = subgameBackground[r][c];
                    if (tile >= 0) {
                        let tileRow = Math.floor(tile / tilesPerRow);
                        let tileCol = Math.floor(tile % tilesPerRow);
                        context.drawImage(grassImage, tileCol * tileSize, tileRow * tileSize, tileSize, tileSize,
                            (c * tileSize) - backgroundCount * 2, r * tileSize, tileSize, tileSize);
                    }
                }
            }

            healthBar(player, context, canvas)

            context.font = "30px Arial";
            context.fillStyle = "red";
            context.fillText("Score:" + String(score), 60, 50);

            if (score < 10*level) {
                if (backgroundCount % 2 === 0) {
                    player.frameX = (player.frameX + 1) % 4;
                }

                context.drawImage(rock, rock1.x, rock1.y - 20, rock1.width * 5, rock1.height * 5);
                rock1.x = rock1.x - 6
                if (rock1.x < 0 - rock1.width) {
                    rock1.x = canvas.width
                }
                context.drawImage(rock, rock2.x, rock2.y - 20, rock2.width * 5, rock2.height * 5);
                rock2.x = rock2.x - 6
                if (rock2.x < 0 - rock2.width) {
                    rock2.x = canvas.width + 20
                }

                context.drawImage(bat,
                    bat1.width * bat1.frameX, bat1.height * bat1.frameY,
                    bat1.width, bat1.height,
                    bat1.x, bat1.y - 10, bat1.width, bat1.height);
                bat1.x = bat1.x - 9
                if (bat1.x < 0 - bat1.width) {
                    bat1.x = canvas.width
                    score += 1
                }

                context.drawImage(playerImage,
                    player.width * player.frameX, player.height * player.frameY,
                    player.width, player.height,
                    player.x, player.y, player.width, player.height);

                if (moveUp && !player.inAir) {
                    player.yChange = player.yChange - 22;
                    player.inAir = true;
                }
                else if (boost && !player.inAir) {
                    player.yChange = player.yChange - 30;
                    player.inAir = true;
                }

                player.y = player.y + player.yChange

                player.yChange = player.yChange + 2.5
                player.yChange = player.yChange * .9

                if (player.y + player.height > floor) {
                    player.inAir = false;
                    player.y = floor - player.height;
                    player.yChange = 0;
                }

                collision(player, rock1)
                collision(player, rock2)
                collision(player, bat1)
            } else {
                context.drawImage(playerImage,
                    player.width * player.frameX, player.height * player.frameY,
                    player.width, player.height,
                    player.x, player.y, player.width, player.height);

                player.frameX = (player.frameX + 1) % 4;
                player.x += 5;

                if (player.x > 512) {
                    score += 1
                }

            }

        }

        window.addEventListener("keydown", activate, false);
        window.addEventListener("keyup", deactivate, false);
    }
    function activate(event) {
        let key = event.key;
        if (key === "ArrowUp") {
            moveUp = true;
        }
        else if (key === " ") {
            boost = true;
            paused = false
        }
    }

    function deactivate(event) {
        let key = event.key;
        if (key === "ArrowUp") {
            moveUp = false;
        }
        else if (key === " ") {
            boost = false;
        }
    }

    function collision(player, obstacle) {
        // cases of collision
        if (!((player.x > obstacle.x + obstacle.width) ||
            ((player.x - 15 + player.width < obstacle.x)) ||
            ((player.y - 10 + player.height < obstacle.y)) ||
            ((player.y > obstacle.y)))) {
            player.health -= level
        }
    }
}



function level1() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    assignObstacles(background1, obstacleList, tileSize, [1, 7])
    lizard.x = 300
    lizard.y = 200
    enemiesList.push(lizard);
}


function drawLevel1() {
    if (level === 1) {
        request = window.requestAnimationFrame(drawLevel1);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);
        tilesPerRow = 6
        drawBackground(context, background1, canvas, tilesPerRow, grassImage, tileSize)
        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)
        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }

}



//level2()
function level2() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []
    //assignObstacles(background2, obstacleList, tileSize, [48])
    let skeleton = {
        x: 132,
        y: 48,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        count: 0,
        health: 100,
        wepon: "bow",
        bowFrameX: 0,
        bowFrameY: 0,
        character: "skeleton",
        movement: true
    };
    skeleton.x = 300
    skeleton.y = 200
    enemiesList.push(skeleton);
}

function drawLevel2() {
    if (level === 2) {
        request = window.requestAnimationFrame(drawLevel2);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);
        tilesPerRow = 16
        drawBackground(context, background2, canvas, tilesPerRow, sewerImage, tileSize)
        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)
        GameOver(player, context, request) 
        // possible optimise
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
        
    }

}

//level3()
function level3() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []

    //assignObstacles(background3, obstacleList, tileSize, [66, 67, 65])
    let skeleton = {
        x: 300,
        y: 200,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        count: 0,
        health: 100,
        wepon: "bow",
        bowFrameX: 0,
        bowFrameY: 0,
        character: "skeleton",
        movement: true
    };

    enemiesList.push(skeleton);
    let skeleton1 = {
        x: 132,
        y: 48,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        count: 0,
        health: 100,
        wepon: "bow",
        bowFrameX: 0,
        bowFrameY: 0,
        character: "skeleton",
        movement: true
    };
    enemiesList.push(skeleton1);
}

function drawLevel3() {
    if (level === 3) {
        request = window.requestAnimationFrame(drawLevel3);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);
        tilesPerRow = 13
        drawBackground(context, background3, canvas, tilesPerRow, desertImage, tileSize)
        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)
        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }
}

//level4()
function level4() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []

    //assignObstacles(background4, obstacleList, tileSize, [66])
    let wizard = {
        x: 100,
        y: 100,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        health: 100,
        character: "wizard",
        spellX: 0,
        spellY: 0,
        spellCount: 0,
        count: 0,
        movement: true
    };
    enemiesList.push(wizard);
    let wizard1 = {
        x: 400,
        y: 100,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        health: 100,
        character: "wizard",
        spellX: 0,
        spellY: 0,
        spellCount: 0,
        count: 0,
        movement: true
    };
    enemiesList.push(wizard1);
}

function drawLevel4() {
    if (level === 4) {
        request = window.requestAnimationFrame(drawLevel4);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);
        tilesPerRow = 13
        drawBackground(context, background4, canvas, tilesPerRow, desertImage, tileSize)

        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)
        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }
}

//level5()
function level5() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []

    //assignObstacles(background5, obstacleList, tileSize, [13, 27, 15, 66])

    let skeleton = {
        x: 300,
        y: 200,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        count: 0,
        health: 100,
        wepon: "bow",
        bowFrameX: 0,
        bowFrameY: 0,
        character: "skeleton",
        movement: true
    };
    let wizard = {
        x: 100,
        y: 100,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        health: 100,
        character: "wizard",
        spellX: 0,
        spellY: 0,
        spellCount: 0,
        count: 0,
        movement: true
    };

    wizard.x = 300
    wizard.y = 200
    enemiesList.push(wizard);
    enemiesList.push(skeleton);
    landmineList.push(landmine)
}

function drawLevel5() {
    if (level === 5) {
        request = window.requestAnimationFrame(drawLevel5);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);
        tilesPerRow = 10;
        drawBackground(context, background5, canvas, tilesPerRow, tiny16Image, tileSize)

        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)

        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }
}

//level6()
function level6() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []

    //assignObstacles(background6, obstacleList, tileSize, [27, 17, 18, 37, 19])

    let wizard = {
        x: 100,
        y: 100,
        height: 48,
        width: 32,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        health: 100,
        character: "wizard",
        spellX: 0,
        spellY: 0,
        spellCount: 0,
        count: 0,
        movement: true
    };
    enemiesList.push(wizard);


}

function drawLevel6() {
    if (level === 6) {
        request = window.requestAnimationFrame(drawLevel6);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);

        drawBackground(context, background6, canvas, tilesPerRow, tiny16Image, tileSize)
        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        blackout(context, player, canvas)

        healthBar(player, context, canvas)
        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }
}

//level7()
function level7() {
    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []

    tileSize = 24
    //assignObstacles(background7, obstacleList, tileSize, [83, 33, 86, 84])

    let lizard = {
        x: 32,
        y: 48,
        height: 48,
        width: 39,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        character: "lizard",
        count: 0,
        health: 100,
        movement: true
    };

    lizard.x = 300
    lizard.y = 300
    enemiesList.push(lizard);
}

function drawLevel7() {
    if (level === 7) {
        request = window.requestAnimationFrame(drawLevel7);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);

        tileSize = 24;
        tilesPerRow = 16;
        drawBackground(context, background7, canvas, tilesPerRow, caveImage, tileSize)
        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)
        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }
}


function level8() {

    backgroundCountX = 0;
    backgroundCountY = 0;
    enemiesList = []
    landmineList = []
    obstacleList = []
    arrowList = []
    tileSize = 24
    assignObstacles(background7, obstacleList, tileSize, [83, 33, 86, 84])

    let dragon = {
        x: 360,
        y: 50,
        height: 96,
        width: 96,
        frameX: 0,
        frameY: 0,
        xChange: 1,
        yChange: 0,
        health: 400,
        character: "dragon",
        count: 0,
        movement: true
    };
    enemiesList.push(dragon);

    let landmine = {
        x: 180,
        y: 250,
        height: 16,
        width: 16,
        distance: 1000,
        pictureWidth: 256,
        pictureHeight: 256,
        pictureX: 0,
        pictureY: 0,
        explode: false
    }

    landmineList.push(landmine)

    landmine = {
        x: 280,
        y: 250,
        height: 16,
        width: 16,
        distance: 1000,
        pictureWidth: 256,
        pictureHeight: 256,
        pictureX: 0,
        pictureY: 0,
        explode: false
    }

    landmineList.push(landmine)

    landmine = {
        x: 380,
        y: 250,
        height: 16,
        width: 16,
        distance: 1000,
        pictureWidth: 256,
        pictureHeight: 256,
        pictureX: 0,
        pictureY: 0,
        explode: false
    }

    landmineList.push(landmine)
}

function drawLevel8() {
    if (level === 8) {
        request = window.requestAnimationFrame(drawLevel8);
        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);
        tileSize = 24;
        tilesPerRow = 16;
        drawBackground(context, background7, canvas, tilesPerRow, caveImage, tileSize)
        common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
            moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage)

        healthBar(player, context, canvas)
        GameOver(player, context, request)
        if (enemiesList.length === 0) {
            level += 1
        }
        levelComplete(enemiesList)
    }
}


function deactivate(event) {
    let key = event.key;
    if (key === "ArrowDown") {
        moveDown = false;
    } else if (key === "ArrowUp") {
        moveUp = false;
    } else if (key === "ArrowRight") {
        moveRight = false;
    } else if (key === "ArrowLeft") {
        moveLeft = false;
    }
}

function activate(event) {
    let key = event.key;
    if (key === "ArrowDown") {
        moveDown = true;
    } else if (key === "ArrowUp") {
        moveUp = true;
    } else if (key === "ArrowRight") {
        moveRight = true;
    } else if (key === "ArrowLeft") {
        moveLeft = true;
    }
    if (key === "f") {
        shoot(player, arrowList, enemiesList)
    }
    if (key === "h") {
        hit(player, context, enemiesList, arrowList)
    }
}


function assignObstacles(background, obstacleList, tileSize, obstacleInputList) {
    for (let r = 0; r < 20; r += 1) {
        for (let c = 0; c < 32; c += 1) {
            let tile = background[r][c];
            if (obstacleInputList.includes(tile)) {
                let obstacle = {
                    x: c * tileSize,
                    y: r * tileSize,
                    height: tileSize,
                    width: tileSize
                }
                obstacleList.push(obstacle);
            }
        }
    }
}

function randint(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
}


function moveMapCollision(person, obstacle, backgroundCountX, backgroundCountY) {
    if ((person.x > obstacle.x + (obstacle.width * .5) - (backgroundCountX * 8))) {
        person.x = obstacle.x + obstacle.width + 2 - (backgroundCountX * 8)
    }
    if ((person.x + person.width < obstacle.x + (obstacle.width * .5) - (backgroundCountX * 8))) {
        person.x = obstacle.x - (person.width + 2) - (backgroundCountX * 8)
    }
    if ((person.y + person.height < (obstacle.y + (obstacle.height * .5)) - (backgroundCountY * 5))) {
        person.y = obstacle.y - (person.height + 2) - (backgroundCountY * 5)
    }
    if ((person.y > obstacle.y + (obstacle.height * .5) - (backgroundCountY * 5))) {
        person.y = obstacle.y + obstacle.height + 2 - (backgroundCountY * 5)
    }
    /*
    // Optimisable
    if (person.movement === false && person.character != "player") {
        person.movement = true
        person.x = canvas.width*.5
        person.y = canvas.height*.5
    }
    if (person.xChange === 0 && person.yChange === 0 && person.character != "player") {
        person.movement = false
    }
    if (person.character === "player" && (moveRight||moveUp||moveLeft||moveRight) && person.xChange === 0 && person.yChange === 0) {
        person.x = canvas.width*.5
        person.y = canvas.height*.5
    }
    */
    person.yChange = 0
    person.xChange = 0
}

function shoot(person, arrowList, target) {
    person.wepon = "bow"
    let arrow = {
        x: person.x + (.5 * person.width),
        y: person.y + (.5 * person.height),
        frameY: 0,
        height: 256,
        width: 256,
        shooter: person
    }
    // NEXT 2 INPUTS CAN BE OPTIMISED 
    if (person.character === "player") {
        if (target.length === 0) {
            arrow.frameX = 1;
            arrow.direction = -1;
        } else if (person.x > target[0].x) {
            arrow.frameX = 1;
            arrow.direction = -1;
        } else {
            arrow.frameX = 3;
            arrow.direction = 1;
        }
    } else if (person.character === "skeleton") {
        if (person.x > target.x) {
            arrow.frameX = 1;
            arrow.direction = -1;
        } else {
            arrow.frameX = 3;
            arrow.direction = 1;
        }
    }
    arrowList.push(arrow)
}

function hit(player, context, enemiesList, arrowList) {
    player.wepon = "sword"
    context.strokeStyle = "orange";
    context.lineWidth = 10;
    context.beginPath();
    if (player.frameY === 0) {
        context.arc(player.x + 15, player.y + 30, 25, .8 * Math.PI, 2.2 * Math.PI, true);
    } else if (player.frameY === 1) {
        context.arc(player.x + 15, player.y + 25, 30, 1.4 * Math.PI, .6 * Math.PI, true);
    } else if (player.frameY === 2) {
        context.arc(player.x + 15, player.y + 25, 30, 1.6 * Math.PI, 2.4 * Math.PI);
    } else if (player.frameY === 3) {
        context.arc(player.x + 15, player.y + 20, 25, 1.2 * Math.PI, 1.8 * Math.PI);
    }
    context.stroke();
    for (let enemy of enemiesList) {
        checkHit(player, enemy, arrowList, true)
    }
}

function checkHit(attacker, target, arrowList, swordHit) {
    if (attacker.wepon === "sword" && swordHit === true) {
        if (attacker.frameY === 0) {
            // Can be optimised
            if (((attacker.y - 20 < target.y) && (target.y < attacker.y + attacker.height + 40)) && ((attacker.x - 10 < target.x) && (attacker.x < target.x + target.width + 10))) {
                target.health -= 10
                target.y += 30
            }
        } else if (attacker.frameY === 1) {
            if (((attacker.y - 30 < target.y) && (target.y < attacker.y + attacker.height)) && ((attacker.x - 45 < target.x) && (target.x < attacker.x + attacker.width))) {
                target.health -= 10
                target.x -= 30
            }
        } else if (attacker.frameY === 2) {
            if (((attacker.y - 40 < target.y) && (target.y < attacker.y + attacker.height)) && ((attacker.x + attacker.width - 20 < target.x) && (target.x < attacker.x + attacker.width + 25))) {
                target.health -= 10
                target.x += 30
            }
        } else if (attacker.frameY === 3) {
            if (((attacker.y > target.y + target.height) && (target.y - 40 < attacker.y + attacker.height)) && ((attacker.x - 10 < target.x) && (target.x < attacker.x + attacker.width + 10))) {
                target.health -= 10
                target.y -= 30
            }
        }
        if (target.x < 0) {
            target.x = 0
        }
        if (target.x + target.width > 512) {
            target.x = 512 - target.width
        }
    } else if (attacker.wepon === "bow") {
        for (let arrow of arrowList) {
            if (target.health > 0) {
                if ((arrow.x < target.x + target.width && arrow.x + arrow.width - 240 > target.x) && (target.y + target.height > arrow.y && target.y < arrow.y + arrow.height - 240)) {
                    if ((target != arrow.shooter)) {
                        target.health -= 5
                        let index = arrowList.indexOf(arrow);
                        arrowList.splice(index, 1);
                    }
                }
            }
        }
    }
}

function enemyRandomMove(enemy) {
    if (enemy.health > 0) {
        if (enemy.count === 0) {
            enemy.count = 10
            enemy.xChange = randint(1, 4)
        } else {
            enemy.frameX = (enemy.frameX + 1) % 4;
            enemy.count -= 1
            if (enemy.xChange === 1) {
                enemy.frameY = 0;
                enemy.y = enemy.y + 4;
            } else if (enemy.xChange === 2) {
                enemy.frameY = 1;
                enemy.x = enemy.x - 4;
            } else if (enemy.xChange === 3) {
                enemy.frameY = 3;
                enemy.y = enemy.y - 4;
            } else if (enemy.xChange === 4) {
                enemy.frameY = 2;
                enemy.x = enemy.x + 4;
            }
        }
    }
}

function dragonMove(enemy, player) {
    if (enemy.health > 0) {
        if (player.y + player.height >= enemy.y + enemy.height) {
            enemy.y += 3
            enemy.frameY = 0
        } else if (player.y + player.height <= enemy.y) {
            enemy.y -= 3
            enemy.frameY = 3
        } else {
            if (player.x + player.width >= enemy.x + enemy.width) {
                enemy.x += 3
                enemy.frameY = 2
            } else if (player.x + player.width <= enemy.x) {
                enemy.x -= 3
                enemy.frameY = 1
            }
        }
        enemy.frameX = (enemy.frameX + 1) % 4;
    }
}

function enemyYAxisMove(enemy, player, arrowList) {
    if (enemy.health > 0) {
        if (enemy.y - 10 > player.y) {
            enemy.y -= 3;
            enemy.frameY = 3;
        } else if (enemy.y > player.y) {
            enemy.y -= 1;
        } else if (enemy.y + 10 < player.y) {
            enemy.y += 3;
            enemy.frameY = 0;
        } else if (enemy.y < player.y) {
            enemy.y += 1;
        }
        if (!(enemy.y + 3 > player.y && enemy.y - 3 < player.y)) {
            enemy.frameX = (enemy.frameX + 1) % 4;
        } else {
            if (enemy.x < player.x) {
                enemy.frameY = 2;
            } else if (enemy.x > player.x) {
                enemy.frameY = 1;
            }

        }
        let chance = randint(1, 20)
        if (chance === 5) {
            shoot(enemy, arrowList, player)
        }
    }
}

function landmines(landmineList, person, context, landmineImage, explodeImage) {
    for (let landmine of landmineList) {
        if (landmine.explode != false) {
            if (person.character === landmine.explode) {
                context.drawImage(explodeImage,
                    landmine.pictureWidth * landmine.pictureX, landmine.pictureHeight * landmine.pictureY,
                    landmine.pictureWidth, landmine.pictureHeight,
                    landmine.x - 30 - (backgroundCountX * 8), landmine.y - 30 - (backgroundCountY * 5), landmine.width * 5, landmine.height * 5);
                landmine.pictureX += 1
                person.health -= 3;
                if (landmine.pictureX === 8) {
                    landmine.pictureX = 0
                    landmine.pictureY += 1
                    if (landmine.pictureY === 4) {
                        let index = landmineList.indexOf(landmine);
                        landmineList.splice(index, 1);
                    }
                }
            }
        }
        else {
            landmine.distance = ((((person.x + (person.width * .5)) - (landmine.x - (backgroundCountX * 8) + (landmine.width * .5))) ** 2) + ((person.y + (person.height)) - (landmine.y - (backgroundCountY * 5) + (landmine.height * .5))) ** 2) ** .5

            if (landmine.distance < 40 && person.character === "player") {
                landmine.explode = person.character;
            } else if (landmine.distance < 50 && person.character === "dragon") {
                landmine.explode = person.character;


            } else {
                context.drawImage(landmineImage, landmine.x - (backgroundCountX * 8), landmine.y - (backgroundCountY * 5), landmine.width, landmine.height);
            }
        }
    }
}

function spell(enemy, context, player) {
    if (enemy.character === "wizard") {
        enemy.spellCount += 1
        context.lineWidth = 9;
        context.strokeStyle = "yellow";
        context.beginPath();
        if (enemy.spellCount === 1) {
            enemy.spellX = randint(0, 512)
            enemy.spellY = randint(0, 320)
        } else if (enemy.spellCount > 28) {
            context.strokeStyle = "red";
            spellCheck(enemy, player)
            if (enemy.spellCount === 32) {
                enemy.spellCount = 0;
            }
        }
        context.arc(enemy.spellX, enemy.spellY, 25, 0, 2 * Math.PI, true);
        context.stroke()
    }
}

function spellCheck(enemy, player) {
    let distance = ((((player.x + (player.width * .5)) - enemy.spellX) ** 2) + ((player.y + (player.height)) - enemy.spellY) ** 2) ** .5
    if (distance < 25) {
        player.health -= 15
    }
}

function blackout(context, player, canvas) {
    // creates blackout on canves except 
    context.fillStyle = "black";
    context.fillRect(player.x + (player.width) + 50, 0, canvas.width - player.x, canvas.height);
    context.fillRect(player.x - 50, 0, -(canvas.width + player.x), canvas.height);
    context.fillRect(player.x - 60, 0, player.width + 120, player.y - 50);
    context.fillRect(player.x - 60, player.y + player.height + 50, player.width + 120, (canvas.height - (player.y + player.height)));
    context.strokeStyle = "black";
    context.lineWidth = 50;
    context.beginPath();
    context.arc(player.x + (player.width * .5), player.y + (player.height * .5), 90, 0, 2 * Math.PI, true);
    context.stroke()
}

function drawBackground(context, background, canvas, tilesPerRow, backgroundImage, tileSize) {
    //combine with level 7
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = "black";
    if (background[1][1] === -1) {
        context.fillStyle = "lightgreen";
    }
    context.fillRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < 20; r += 1) {
        for (let c = 0; c < 32; c += 1) {
            let tile = background[r][c];
            if (tile >= 0) {
                let tileRow = Math.floor(tile / tilesPerRow);
                let tileCol = Math.floor(tile % tilesPerRow);
                if (tileSize === 24) {
                    context.drawImage(backgroundImage, tileCol * tileSize, tileRow * tileSize, tileSize, tileSize, (c * tileSize) - backgroundCountX * 8, (r * tileSize) - backgroundCountY * 5, tileSize, tileSize);

                } else {
                    context.drawImage(backgroundImage, tileCol * tileSize, tileRow * tileSize, tileSize, tileSize, c * tileSize, r * tileSize, tileSize, tileSize);
                }
            }
        }
    }
}

function common(canvas, context, player, enemiesList, obstacleList, playerImage, lizardImage, skeletonImage, wizardImage,
    moveDown, moveLeft, moveRight, moveUp, sword, bow, arrowList, bowImage, swordImage, arrowSpeed, arrowImage) {

    if (player.health > 0) {
        context.drawImage(playerImage,
            player.width * player.frameX, player.height * player.frameY,
            player.width, player.height,
            player.x, player.y, player.width, player.height);
    }

    for (let enemy of enemiesList) {
        if (enemy.health > 0) {
            // drawing images optimisable
            if (enemy.character === "lizard") {
                enemyRandomMove(enemy)
                context.drawImage(lizardImage,
                    enemy.width * enemy.frameX, enemy.height * enemy.frameY,
                    enemy.width, enemy.height,
                    enemy.x, enemy.y, enemy.width, enemy.height);
            } else if (enemy.character === "wizard") {
                enemyRandomMove(enemy)
                spell(enemy, context, player)
                context.drawImage(wizardImage,
                    enemy.width * enemy.frameX, enemy.height * enemy.frameY,
                    enemy.width, enemy.height,
                    enemy.x, enemy.y, enemy.width, enemy.height);
            } else if (enemy.character === "skeleton") {
                enemyYAxisMove(enemy, player, arrowList)
                context.drawImage(skeletonImage,
                    enemy.width * enemy.frameX, enemy.height * enemy.frameY,
                    enemy.width, enemy.height,
                    enemy.x, enemy.y, enemy.width, enemy.height);
            } else if (enemy.character === "dragon") {
                dragonMove(enemy, player)
                context.drawImage(dragonImage,
                    enemy.width * enemy.frameX, enemy.height * enemy.frameY,
                    enemy.width, enemy.height,
                    enemy.x, enemy.y, enemy.width, enemy.height);
            }
        }
    }

    if ((moveLeft || moveRight || moveUp || moveDown) && !(moveLeft && moveRight)) {
        player.frameX = (player.frameX + 1) % 4;
        if (player.wepon === "sword") {
            sword.frameX = (((sword.frameX - 2) + 1) % 2) + 2;
        } else {
            bow.frameX = (((bow.frameX - 1 - bow.frameY) + 1) % 2) + 1 + bow.frameY;
        }
    }

    if (moveLeft) {
        player.xChange = player.xChange - 0.8;
        player.frameY = 1;
        sword.frameY = 2;
        bow.frameY = 0;
    }
    if (moveRight) {
        player.xChange = player.xChange + 0.8;
        player.frameY = 2;
        sword.frameY = 3;
        bow.frameY = 1;
    }
    if (moveUp) {
        player.yChange = player.yChange - 0.8;
        player.frameY = 3;
        sword.frameY = 0;
        bow.frameY = 4;
    }
    if (moveDown) {
        player.yChange = player.yChange + 0.8;
        player.frameY = 0;
        sword.frameY = 1;
        bow.frameY = 4;
    }

    // player and enemy bow could be combined
    if (player.health > 0) {
        if (!(sword.frameY === 0) && player.wepon === "sword") {
            context.drawImage(swordImage,
                sword.width * sword.frameX, sword.height * sword.frameY,
                sword.width, sword.height,
                player.x - 20, player.y - 35, sword.width * .3, sword.height * .4);
        } else if (player.wepon === "bow" && !(bow.frameY === 4)) {
            context.drawImage(bowImage,
                bow.width * bow.frameX, bow.height * 3,
                bow.width, bow.height,
                player.x + 5, player.y + 10, bow.width * .3, bow.height * .4);
        }
    }

    for (let enemy of enemiesList) {
        if (enemy.health > 0 && enemy.character === "skeleton") {
            if ((enemy.frameY === 1 || enemy.frameY === 2)) {
                if (enemy.frameY === 1) {
                    enemy.bowFrameY = 3
                } else {
                    enemy.bowFrameY = 0
                }
                context.drawImage(bowImage,
                    enemy.bowFrameX * bow.width, enemy.bowFrameY * bow.height,
                    bow.width, bow.height,
                    enemy.x + 5, enemy.y + 10, bow.width * .3, bow.height * .4);
            }
        }
    }

    for (let arrow of arrowList) {
        arrow.x = arrow.x + (arrowSpeed * arrow.direction);
        context.drawImage(arrowImage,
            arrow.width * arrow.frameX, arrow.height * arrow.frameY,
            arrow.width, arrow.height,
            arrow.x - 30, arrow.y - 22, arrow.width * .2, arrow.height * .2);
        if (arrow.x > canvas.width || arrow.x < -arrow.width * 2) {
            let index = arrowList.indexOf(arrow);
            arrowList.splice(index, 1);
        }
    }
    for (let enemy of enemiesList) {
        checkHit(player, enemy, arrowList, false)
        checkHit(enemy, player, arrowList, false)
        landmines(landmineList, enemy, context, landmineImage, explodeImage)
    }

    landmines(landmineList, player, context, landmineImage, explodeImage)

    // obstacles
    for (let obstacle of obstacleList) {
        // if player hits background obstacle
        if ((player.x + player.width > obstacle.x - (backgroundCountX * 8) && player.x < obstacle.x + obstacle.width - (backgroundCountX * 8)) && (player.y + player.height > obstacle.y - (backgroundCountY * 5) && player.y < obstacle.y + obstacle.height - (backgroundCountY * 5))) {
            moveMapCollision(player, obstacle, backgroundCountX, backgroundCountY)
        }
        for (let enemy of enemiesList) {
            if ((enemy.x + enemy.width > obstacle.x - (backgroundCountX * 8) && enemy.x < obstacle.x + obstacle.width - (backgroundCountX * 8)) && (enemy.y + enemy.height > obstacle.y - (backgroundCountY * 5) && enemy.y < obstacle.y + obstacle.height - (backgroundCountY * 5))) {
                moveMapCollision(enemy, obstacle, backgroundCountX, backgroundCountY)
            }
            if ((enemy.health) > 0 && (player.x + player.width > enemy.x && player.x < enemy.x + enemy.width) && (player.y + player.height > enemy.y && player.y < enemy.y + enemy.height)) {
                if (enemy.character === "dragon") {
                    player.health = 0;
                } else {
                    moveMapCollision(player, enemy, backgroundCountX, backgroundCountY)
                    player.health -= 5
                }
            }
        }
    }


    player.x = player.x + player.xChange
    player.y = player.y + player.yChange

    player.yChange = player.yChange * .9
    player.xChange = player.xChange * .9

    for (let enemy of enemiesList) {
        if (enemy.health > 0) {
            if (enemy.x < -(backgroundCountX * 8)) {
                enemy.xChange = 4;
            } else if (enemy.x + enemy.width > canvas.width + ((32 - backgroundCountX) * 8)) {
                enemy.xChange = 2;
            }
            if (enemy.y < -(backgroundCountY * 5)) {
                enemy.xChange = 1;
            } else if (enemy.y + enemy.height > canvas.height + ((20 - backgroundCountX) * 5)) {
                enemy.xChange = 3;
            }
        }
    }

    let displaceX = 0
    let displaceY = 0
    if (player.x < -2) {
        player.x = -2;
        if (backgroundCountX > 0 && moveLeft && tileSize > 16) {
            backgroundCountX -= 1
            displaceX = 8
        }
    } else if (player.x + player.width > canvas.width) {
        player.x = canvas.width - player.width;
        if (backgroundCountX < 32 && moveRight && tileSize > 16) {
            backgroundCountX += 1
            displaceX = -8
        }
    }
    if (player.y < 0) {
        player.y = 0;
        if (backgroundCountY > 0 && moveUp && tileSize > 16) {
            backgroundCountY -= 1
            displaceY = 5
        }
    } else if (player.y + player.height > canvas.height) {
        player.y = canvas.height - player.height;
        if (backgroundCountY < 20 && moveDown && tileSize > 16) {
            backgroundCountY += 1
            displaceY = -5
        }
    }
    for (let enemy of enemiesList) {
        enemy.x += displaceX
        enemy.y += displaceY
    }


    // healthbars
    // enemy health
    for (let enemy of enemiesList) {
        if (enemy.health > 0) {
            context.fillStyle = "red";
            context.fillRect(enemy.x + 2, enemy.y - 10, .3 * enemy.health, 2);
        } else {
            let index = enemiesList.indexOf(enemy);
            enemiesList.splice(index, 1);
        }
    }
}

function healthBar(player, context, canvas) {
    if (player.health > 0) {
        context.fillStyle = "black";
        context.fillRect((canvas.width * .5) - 105, 15, 210, 15);
        context.fillStyle = "red";
        context.fillRect((canvas.width * .5) - 100, 19, 2 * player.health, 7);
    }
}


function pause() {
    context.font = "20px Ariel";
    context.fillStyle = "white";
    context.textAlign = "center";
    context.fillText("Press Space to Continue", canvas.width / 2, canvas.height / 2);
}


function chooseCharacter() {
    if (characterSelection === false) {
        request = window.requestAnimationFrame(chooseCharacter);

        let now = Date.now();
        let elapsed = now - then;
        if (elapsed <= fpsInterval) {
            return;
        };
        then = now - (elapsed % fpsInterval);

        player.frameX = (player.frameX + 1) % 4;

        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "grey";
        context.fillRect(0, 0, canvas.width, canvas.height);

        context.drawImage(characterMale,
            player.width * player.frameX, player.height * player.frameY,
            player.width, player.height,
            canvas.width * .25 - (player.width * .5), canvas.height * .5, player.width, player.height);

        context.drawImage(characterFemale,
            player.width * player.frameX, player.height * player.frameY,
            player.width, player.height,
            canvas.width * .75 - (player.width * .5), canvas.height * .5, player.width, player.height);

        context.font = "20px Ariel";
        context.fillStyle = "white";
        context.textAlign = "center";
        context.fillText("Click to choose your character", canvas.width / 2, 250);

        canvas.addEventListener("click", mouseClick, false)
    }

    function mouseClick(event) {

        let keyX = event.pageX
        let keyY = event.pageY
        let fullWidth = document.getElementById("html").clientWidth
        let fullHeight = document.getElementById("html").clientHeight
        if ((fullWidth - canvas.width) * .5 < keyX && (keyX < (fullWidth - (fullWidth - canvas.width) * .5))) {
            if (keyX < ((fullWidth - canvas.width) * .5) + (.5 * canvas.width)) {
                playerImage.src = "nightelf_male1.png";
            } else {
                playerImage.src = "nightelf_female.png";
            }
            characterSelection = true
            levelComplete(enemiesList)
        }
    }
}


function GameOver(player, context, request) {
    if (player.health <= 0) {
        context.drawImage(gameover, canvas.width * .5 - 70, 100, 140, 100);
        window.cancelAnimationFrame(request)
    }
}

function levelComplete(enemiesList) {
    if (!characterSelection) {
        document.getElementById("title").innerHTML = "Character";
        chooseCharacter()
    }
    if (enemiesList.length === 0) {
        if (level === 1) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                document.getElementById("underGame").innerHTML =
                    "Use the arrow keys to move around<br>Press H to attack with your sword<br>Lizards will attack if you get too close<br>Kill all the enemies to get to the next level";
                level1()
                drawLevel1()
                
            } else {
                document.getElementById("underGame").innerHTML =
                    "You must get through this mini-game before the next level<br>You will lose health if you hit an obstacle<br>Use Up-Arrow for small jump<br>Use Space Bar for high jump";
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 2) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "Skeletons will try to shoot you<br>You can shoot back by pressing F";
            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                level2()
                drawLevel2()
            } else {
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 3) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "There can be multiple enemies at one time<br>You can only shoot one at a time";
            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                level3()
                drawLevel3()
            } else {
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 4) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "Wizards cast spells on the floor<br>Make sure your feet are outside the circle when they turn red!";
            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                level4()
                drawLevel4()
            } else {
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 5) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "Landmines will explode if you walk near them<br>They won't affect normal enemies";
            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                level5()
                drawLevel5()
            } else {
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 6) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "You must defeat the enemies in the dark<br>Your arrows will tell you what side the enemy is on";

            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                level6()
                drawLevel6()
            } else {
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 7) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "You can explore this map by running into the edge of the screen<br>You should try running to the right first";

            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30

                fpsInterval = 1000 / 15
                level7()
                drawLevel7()
            } else {
                player.health = 100
                subgameFinished = subgame()
            }
        } else if (level === 8) {
            document.getElementById("title").innerHTML = "Level " + String(level);
            document.getElementById("underGame").innerHTML =
                "Touching a dragon will kill you instantly<br>They will be hurt if they walk over landmines";

            if (score === 0) {
                fpsInterval = 1000 / 30
                tilesPerRow = 6
                player.x = (canvas.width / 2) - 150;
                player.y = floor - player.height;
                player.frameY = 2
            }
            if (score > 10) {
                player.x = 30
                fpsInterval = 1000 / 15
                level8()
                drawLevel8()
            } else {
                subgameFinished = subgame()
            }
        }
    }
}
function drawAll(){
    request = window.requestAnimationFrame(subgame);
}